{"version":3,"file":"static/js/513.b52fbb93.chunk.js","mappings":"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","sources":["backend/data-service.js"],"sourcesContent":["class DataService {\r\n    constructor(config = null) {\r\n        // Storage account settings for Azure Blob\r\n        this.config = config || {\r\n          accountName: process.env.REACT_APP_AZURE_ACCOUNT_NAME,\r\n          containerName: process.env.REACT_APP_AZURE_CONTAINER_NAME\r\n        };\r\n        \r\n        // Cache for loaded JSON files\r\n        this.dataCache = new Map();\r\n        this.cacheTTL = 5 * 60 * 1000; // 5 minutes\r\n        \r\n        // Flag to track if we've initialized connections\r\n        this.initialized = false;\r\n    }      \r\n  \r\n  /**\r\n  * Modified method to initialize Azure storage connections for browser environments\r\n  */\r\n  async initialize() {\r\n    if (this.initialized) return true;\r\n    \r\n    try {      \r\n      await this.testConnection();\r\n      \r\n      this.initialized = true;\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to initialize Azure Blob Storage connection:', error);\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Test connection to Azure Blob Storage\r\n   */\r\n  async testConnection() {\r\n    try {\r\n      // Try to access a small file to verify connection works\r\n      const testUrl = this.generateSasUrl('analysis/user_profiles_summary.json');\r\n      const response = await fetch(testUrl);\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error: ${response.status}`);\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Test connection failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Generate a SAS URL for a blob\r\n   * @param {string} blobPath - Path to the blob\r\n   * @returns {string} The SAS URL\r\n   */\r\n  generateSasUrl(blobPath) {\r\n    const baseUrl = `https://${this.config.accountName}.blob.core.windows.net/${this.config.containerName}`;\r\n    \r\n    const sasToken = process.env.REACT_APP_AZURE_SAS_TOKEN;\r\n    \r\n    return `${baseUrl}/${blobPath}${sasToken}`;\r\n  }\r\n  \r\n  /**\r\n  * Load a JSON file from Azure Blob Storage\r\n  * @param {string} path - The path to the JSON file\r\n  * @returns {Promise<object>} The parsed JSON data\r\n  */\r\n  async loadJsonFile(path) {\r\n    // Check cache first\r\n    const cacheKey = `json:${path}`;\r\n    const cachedData = this.checkCache(cacheKey);\r\n    if (cachedData) {\r\n      return cachedData;\r\n    }\r\n    \r\n    try {\r\n      // Ensure we're initialized\r\n      await this.ensureInitialized();\r\n      \r\n      // Generate SAS URL for the blob\r\n      const url = this.generateSasUrl(path);\r\n      \r\n      // Fetch the file\r\n      const response = await fetch(url);\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error: ${response.status}`);\r\n      }\r\n      \r\n      // Parse JSON\r\n      const data = await response.json();\r\n      \r\n      // Store in cache\r\n      this.setCache(cacheKey, data);\r\n      \r\n      return data;\r\n    } catch (error) {\r\n      console.error(`Error loading JSON file ${path}:`, error);\r\n      return null;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get top users based on query entities\r\n   * @param {object} entities - Extracted entities from the query\r\n   * @returns {Promise<object>} Data for top users\r\n   */\r\n  async getTopUsers(entities) {\r\n    // Ensure we're initialized\r\n    await this.ensureInitialized();\r\n    \r\n    try {\r\n      // Load user profile data\r\n      const userProfiles = await this.loadJsonFile('analysis/unified_user_profiles.json');\r\n      \r\n      if (!userProfiles || Object.keys(userProfiles).length === 0) {\r\n        throw new Error('User profile data not available');\r\n      }\r\n      \r\n      // Filter users based on query entities\r\n      let filteredUsers = Object.entries(userProfiles).map(([email, profile]) => {\r\n        return {\r\n          email,\r\n          name: `${profile.personal_info?.first_name || ''} ${profile.personal_info?.last_name || ''}`.trim(),\r\n          specialty: profile.personal_info?.specialty,\r\n          profession: profile.personal_info?.profession_type || profile.personal_info?.profession,\r\n          engagementScore: profile.engagement_metrics?.engagement_score || 0,\r\n          openRate: profile.engagement_metrics?.open_rate ? profile.engagement_metrics.open_rate * 100 : 0,\r\n          clickRate: profile.engagement_metrics?.click_rate ? profile.engagement_metrics.click_rate * 100 : 0,\r\n          responseTime: profile.engagement_metrics?.avg_response_time,\r\n          topics: profile.content_preferences?.top_topics || []\r\n        };\r\n      });\r\n      \r\n      // Apply specialty filter if specified\r\n      if (entities.specialties && entities.specialties.length > 0) {\r\n        filteredUsers = filteredUsers.filter(user => \r\n          user.specialty && entities.specialties.some(s => \r\n            user.specialty.toLowerCase().includes(s.toLowerCase())\r\n          )\r\n        );\r\n      }\r\n      \r\n      // Apply profession filter if specified\r\n      if (entities.professions && entities.professions.length > 0) {\r\n        filteredUsers = filteredUsers.filter(user => \r\n          user.profession && entities.professions.some(p => \r\n            user.profession.toLowerCase().includes(p.toLowerCase())\r\n          )\r\n        );\r\n      }\r\n      \r\n      // Apply topic filter if specified\r\n      if (entities.topics && entities.topics.length > 0) {\r\n        filteredUsers = filteredUsers.filter(user => \r\n          user.topics && user.topics.some(topic => \r\n            entities.topics.some(t => \r\n              topic.topic && topic.topic.toLowerCase().includes(t.toLowerCase())\r\n            )\r\n          )\r\n        );\r\n      }\r\n      \r\n      // Determine sort metric based on entities.metrics\r\n      let sortMetric = 'engagementScore';\r\n      if (entities.metrics && entities.metrics.length > 0) {\r\n        if (entities.metrics.includes('open_rate')) {\r\n          sortMetric = 'openRate';\r\n        } else if (entities.metrics.includes('click_rate')) {\r\n          sortMetric = 'clickRate';\r\n        }\r\n      }\r\n      \r\n      // Sort by the determined metric\r\n      filteredUsers.sort((a, b) => b[sortMetric] - a[sortMetric]);\r\n      \r\n      // Limit to top 20 or specified limit\r\n      const limit = entities.limit || 20;\r\n      const topUsers = filteredUsers.slice(0, limit);\r\n      \r\n      // Prepare result\r\n      return {\r\n        users: topUsers,\r\n        totalMatching: filteredUsers.length,\r\n        segment: entities.specialties?.[0] || entities.professions?.[0] || entities.topics?.[0],\r\n        segmentType: entities.specialties?.length ? 'specialty' : \r\n                     entities.professions?.length ? 'profession' : \r\n                     entities.topics?.length ? 'topic' : null,\r\n        sortedBy: sortMetric\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting top users:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get content performance based on query entities\r\n   * @param {object} entities - Extracted entities from the query\r\n   * @returns {Promise<object>} Data for content performance\r\n   */\r\n  async getContentPerformance(entities) {\r\n    // Ensure we're initialized\r\n    await this.ensureInitialized();\r\n    \r\n    try {\r\n      // Load topic affinity data\r\n      const topicData = await this.loadJsonFile('analysis/topic_affinity.json');\r\n      \r\n      if (!topicData || !topicData.topic_summary) {\r\n        throw new Error('Topic data not available');\r\n      }\r\n      \r\n      // Convert topic summary to array for easier filtering/sorting\r\n      let contentItems = Object.entries(topicData.topic_summary).map(([topic, metrics]) => {\r\n        return {\r\n          topic,\r\n          engagementScore: metrics.engagement_score || 0,\r\n          openRate: metrics.open_rate ? metrics.open_rate * 100 : 0,\r\n          clickRate: metrics.click_rate ? metrics.click_rate * 100 : 0,\r\n          totalSent: metrics.total_sent || 0,\r\n          shareRate: metrics.share_rate ? metrics.share_rate * 100 : 0\r\n        };\r\n      });\r\n      \r\n      // Apply topic filter if specified\r\n      if (entities.topics && entities.topics.length > 0) {\r\n        contentItems = contentItems.filter(item => \r\n          entities.topics.some(topic => \r\n            item.topic.toLowerCase().includes(topic.toLowerCase())\r\n          )\r\n        );\r\n      }\r\n      \r\n      // Apply specialty filter by loading audience insights if needed\r\n      if (entities.specialties && entities.specialties.length > 0) {\r\n        const audienceInsights = await this.loadJsonFile('analysis/audience_insights.json');\r\n        \r\n        if (audienceInsights && audienceInsights.specialty_insights) {\r\n          // Get preferred topics for specified specialties\r\n          const specialtyTopics = entities.specialties.flatMap(specialty => {\r\n            const insights = Object.entries(audienceInsights.specialty_insights)\r\n              .find(([s]) => s.toLowerCase().includes(specialty.toLowerCase()));\r\n            \r\n            if (insights && insights[1].preferences && insights[1].preferences.topics) {\r\n              return insights[1].preferences.topics.map(t => t.topic);\r\n            }\r\n            return [];\r\n          });\r\n          \r\n          // Filter content items by specialty topics\r\n          if (specialtyTopics.length > 0) {\r\n            contentItems = contentItems.filter(item => \r\n              specialtyTopics.includes(item.topic)\r\n            );\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Determine sort metric based on entities.metrics\r\n      let sortMetric = 'engagementScore';\r\n      if (entities.metrics && entities.metrics.length > 0) {\r\n        if (entities.metrics.includes('open_rate')) {\r\n          sortMetric = 'openRate';\r\n        } else if (entities.metrics.includes('click_rate')) {\r\n          sortMetric = 'clickRate';\r\n        }\r\n      }\r\n      \r\n      // Sort by the determined metric\r\n      contentItems.sort((a, b) => b[sortMetric] - a[sortMetric]);\r\n      \r\n      // Limit to top 10 or specified limit\r\n      const limit = entities.limit || 10;\r\n      const topContent = contentItems.slice(0, limit);\r\n      \r\n      // Prepare content types if specified\r\n      let contentTypes = [];\r\n      if (entities.campaigns && entities.campaigns.length > 0) {\r\n        contentTypes = entities.campaigns;\r\n      }\r\n      \r\n      // Prepare result\r\n      return {\r\n        content: topContent,\r\n        totalMatching: contentItems.length,\r\n        segment: entities.specialties?.[0] || entities.topics?.[0],\r\n        contentTypes\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting content performance:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get timing insights based on query entities\r\n   * @param {object} entities - Extracted entities from the query\r\n   * @returns {Promise<object>} Data for timing insights\r\n   */\r\n  async getTimingInsights(entities) {\r\n    // Ensure we're initialized\r\n    await this.ensureInitialized();\r\n    \r\n    try {\r\n      // Load time patterns data\r\n      const timePatterns = await this.loadJsonFile('analysis/time_patterns.json');\r\n      \r\n      if (!timePatterns) {\r\n        throw new Error('Time patterns data not available');\r\n      }\r\n      \r\n      // Prepare result\r\n      const result = {\r\n        avgTimeToOpen: timePatterns.overall_metrics?.average_hours_to_open,\r\n        medianTimeToOpen: timePatterns.overall_metrics?.median_hours_to_open,\r\n        peakHours: []\r\n      };\r\n      \r\n      // Get hourly distribution\r\n      if (timePatterns.hourly_distribution) {\r\n        result.peakHours = Object.entries(timePatterns.hourly_distribution)\r\n          .map(([hour, count]) => ({ hour: parseInt(hour), count }))\r\n          .sort((a, b) => b.count - a.count)\r\n          .slice(0, 5);\r\n      }\r\n      \r\n      // Get day of week distribution\r\n      if (timePatterns.day_of_week_distribution) {\r\n        result.dayDistribution = Object.entries(timePatterns.day_of_week_distribution)\r\n          .map(([day, count]) => ({ day, count }));\r\n      }\r\n      \r\n      // Handle specialty-specific timing if requested\r\n      if (entities.specialties && entities.specialties.length > 0) {\r\n        const specialty = entities.specialties[0];\r\n        \r\n        if (timePatterns.specialty_metrics) {\r\n          // Find matching specialty\r\n          const specialtyKey = Object.keys(timePatterns.specialty_metrics)\r\n            .find(key => key.toLowerCase().includes(specialty.toLowerCase()));\r\n          \r\n          if (specialtyKey) {\r\n            result.segment = specialty;\r\n            result.specialtyMetrics = timePatterns.specialty_metrics[specialtyKey];\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Handle profession-specific timing if requested\r\n      if (entities.professions && entities.professions.length > 0) {\r\n        const profession = entities.professions[0];\r\n        \r\n        if (timePatterns.profession_metrics) {\r\n          // Find matching profession\r\n          const professionKey = Object.keys(timePatterns.profession_metrics)\r\n            .find(key => key.toLowerCase().includes(profession.toLowerCase()));\r\n          \r\n          if (professionKey) {\r\n            result.segment = profession;\r\n            result.professionMetrics = timePatterns.profession_metrics[professionKey];\r\n          }\r\n        }\r\n      }\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error('Error getting timing insights:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get audience overview based on query entities\r\n   * @param {object} entities - Extracted entities from the query\r\n   * @returns {Promise<object>} Data for audience overview\r\n   */\r\n  async getAudienceOverview(entities) {\r\n    // Ensure we're initialized\r\n    await this.ensureInitialized();\r\n    \r\n    try {\r\n      // Load multiple data sources for comprehensive overview\r\n      const [userProfilesSummary, engagementMetrics, audienceInsights, topicData] = await Promise.all([\r\n        this.loadJsonFile('analysis/user_profiles_summary.json'),\r\n        this.loadJsonFile('analysis/engagement_metrics.json'),\r\n        this.loadJsonFile('analysis/audience_insights.json'),\r\n        this.loadJsonFile('analysis/topic_affinity.json')\r\n      ]);\r\n      \r\n      if (!userProfilesSummary && !engagementMetrics && !audienceInsights) {\r\n        throw new Error('Audience data not available');\r\n      }\r\n      \r\n      // Prepare overall metrics\r\n      const overallMetrics = {\r\n        totalUsers: userProfilesSummary?.total_profiles || 0,\r\n        avgOpenRate: engagementMetrics?.overall_metrics?.avg_open_rate ? \r\n          engagementMetrics.overall_metrics.avg_open_rate * 100 : 0,\r\n        avgClickRate: engagementMetrics?.overall_metrics?.avg_click_rate ? \r\n          engagementMetrics.overall_metrics.avg_click_rate * 100 : 0\r\n      };\r\n      \r\n      // Get specialty breakdown\r\n      let topSpecialties = [];\r\n      if (userProfilesSummary?.specialties) {\r\n        topSpecialties = Object.entries(userProfilesSummary.specialties)\r\n          .map(([specialty, count]) => ({\r\n            specialty,\r\n            userCount: count,\r\n            avgOpenRate: this.getSpecialtyMetric(engagementMetrics, specialty, 'open_rate') * 100,\r\n            avgClickRate: this.getSpecialtyMetric(engagementMetrics, specialty, 'click_rate') * 100\r\n          }))\r\n          .sort((a, b) => b.userCount - a.userCount)\r\n          .slice(0, 5);\r\n      }\r\n      \r\n      // Get top performing content\r\n      let bestTopics = [];\r\n      if (topicData?.topic_summary) {\r\n        bestTopics = Object.entries(topicData.topic_summary)\r\n          .map(([topic, metrics]) => ({\r\n            topic,\r\n            engagementScore: metrics.engagement_score || 0,\r\n            openRate: metrics.open_rate ? metrics.open_rate * 100 : 0\r\n          }))\r\n          .sort((a, b) => b.engagementScore - a.engagementScore)\r\n          .slice(0, 5);\r\n      }\r\n      \r\n      // Get best send times\r\n      let bestHours = [];\r\n      if (audienceInsights?.content_patterns?.timing_patterns?.best_send_hours) {\r\n        bestHours = Object.entries(audienceInsights.content_patterns.timing_patterns.best_send_hours)\r\n          .map(([hour, count]) => ({ hour: parseInt(hour), count }))\r\n          .sort((a, b) => b.count - a.count);\r\n      }\r\n      \r\n      // Get audience segments\r\n      let segmentSummary = {};\r\n      if (userProfilesSummary?.engagement_tiers) {\r\n        segmentSummary = {\r\n          highEngagement: userProfilesSummary.engagement_tiers.highly_engaged || 0,\r\n          moderateEngagement: userProfilesSummary.engagement_tiers.moderately_engaged || 0,\r\n          lowEngagement: userProfilesSummary.engagement_tiers.low_engagement || 0\r\n        };\r\n      }\r\n      \r\n      // Apply specialty filter if specified\r\n      if (entities.specialties && entities.specialties.length > 0) {\r\n        const specialty = entities.specialties[0];\r\n        \r\n        // Update metrics to be specific to this specialty\r\n        if (engagementMetrics?.specialty_metrics) {\r\n          const specialtyMetrics = Object.entries(engagementMetrics.specialty_metrics)\r\n            .find(([s]) => s.toLowerCase().includes(specialty.toLowerCase()));\r\n          \r\n          if (specialtyMetrics) {\r\n            overallMetrics.avgEngagement = specialtyMetrics[1].avg_engagement || 0;\r\n            overallMetrics.userCount = specialtyMetrics[1].user_count || 0;\r\n          }\r\n        }\r\n        \r\n        // Get preferred content for this specialty\r\n        if (audienceInsights?.specialty_insights) {\r\n          const specialtyInsights = Object.entries(audienceInsights.specialty_insights)\r\n            .find(([s]) => s.toLowerCase().includes(specialty.toLowerCase()));\r\n          \r\n          if (specialtyInsights && specialtyInsights[1].preferences && specialtyInsights[1].preferences.topics) {\r\n            bestTopics = specialtyInsights[1].preferences.topics.map(topic => ({\r\n              topic: topic.topic,\r\n              engagementScore: topic.count / 10\r\n            }));\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Track data sources for debugging\r\n      const dataSources = [];\r\n      if (userProfilesSummary) dataSources.push('user_profiles');\r\n      if (engagementMetrics) dataSources.push('engagement_metrics');\r\n      if (audienceInsights) dataSources.push('audience_insights');\r\n      if (topicData) dataSources.push('topic_affinity');\r\n      \r\n      return {\r\n        overallMetrics,\r\n        topSpecialties,\r\n        contentPreferences: {\r\n          bestTopics,\r\n          timing: { bestHours }\r\n        },\r\n        segmentSummary,\r\n        segment: entities.specialties?.[0],\r\n        _dataSources: dataSources\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting audience overview:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get user profile based on query entities\r\n   * @param {object} entities - Extracted entities from the query\r\n   * @returns {Promise<object>} Data for user profile\r\n   */\r\n  async getUserProfile(entities) {\r\n    // Ensure we're initialized\r\n    await this.ensureInitialized();\r\n    \r\n    try {\r\n      // We need an email to look up a profile\r\n      if (!entities.email) {\r\n        throw new Error('Email required for user profile lookup');\r\n      }\r\n      \r\n      // Load user profiles\r\n      const userProfiles = await this.loadJsonFile('analysis/unified_user_profiles.json');\r\n      \r\n      if (!userProfiles) {\r\n        throw new Error('User profile data not available');\r\n      }\r\n      \r\n      // Look up the profile by email (case-insensitive)\r\n      const email = entities.email.toLowerCase();\r\n      let profile = null;\r\n      \r\n      // Direct lookup first\r\n      if (userProfiles[email]) {\r\n        profile = userProfiles[email];\r\n      } else {\r\n        // Try fuzzy matching if direct lookup fails\r\n        const matchedEmail = Object.keys(userProfiles).find(e => \r\n          e.toLowerCase().includes(email) || email.includes(e.toLowerCase())\r\n        );\r\n        \r\n        if (matchedEmail) {\r\n          profile = userProfiles[matchedEmail];\r\n        }\r\n      }\r\n      \r\n      if (!profile) {\r\n        throw new Error(`No profile found for ${entities.email}`);\r\n      }\r\n      \r\n      // Return the profile\r\n      return {\r\n        email: entities.email,\r\n        personalInfo: profile.personal_info || {},\r\n        engagementMetrics: profile.engagement_metrics || {},\r\n        contentPreferences: profile.content_preferences || {},\r\n        journeyPatterns: profile.journey_patterns || {}\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting user profile:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get specialty engagement based on query entities\r\n   * @param {object} entities - Extracted entities from the query\r\n   * @returns {Promise<object>} Data for specialty engagement\r\n   */\r\n  async getSpecialtyEngagement(entities) {\r\n    // Ensure we're initialized\r\n    await this.ensureInitialized();\r\n    \r\n    try {\r\n      // We need a specialty to look up engagement\r\n      if (!entities.specialties || entities.specialties.length === 0) {\r\n        throw new Error('Specialty required for engagement lookup');\r\n      }\r\n      \r\n      const specialty = entities.specialties[0];\r\n      \r\n      // Load necessary data\r\n      const [engagementMetrics, audienceInsights, topicData] = await Promise.all([\r\n        this.loadJsonFile('analysis/engagement_metrics.json'),\r\n        this.loadJsonFile('analysis/audience_insights.json'),\r\n        this.loadJsonFile('analysis/topic_affinity.json')\r\n      ]);\r\n      \r\n      if (!engagementMetrics && !audienceInsights) {\r\n        throw new Error('Specialty engagement data not available');\r\n      }\r\n      \r\n      // Find specialty in engagement metrics\r\n      let userCount = 0;\r\n      let engagementMetricsData = {};\r\n      \r\n      if (engagementMetrics?.specialty_metrics) {\r\n        // Find closest matching specialty\r\n        const specialtyKey = Object.keys(engagementMetrics.specialty_metrics)\r\n          .find(key => key.toLowerCase().includes(specialty.toLowerCase()));\r\n        \r\n        if (specialtyKey) {\r\n          const metrics = engagementMetrics.specialty_metrics[specialtyKey];\r\n          \r\n          engagementMetricsData = {\r\n            openRate: metrics.avg_engagement || 0,\r\n            clickRate: (metrics.avg_engagement / 2) || 0, \r\n            responseTime: metrics.avg_engagement * 3 || 0\r\n          };\r\n          \r\n          userCount = metrics.user_count || 0;\r\n        }\r\n      }\r\n      \r\n      // Find preferred topics for this specialty\r\n      let preferredTopics = [];\r\n      \r\n      if (audienceInsights?.specialty_insights) {\r\n        // Find closest matching specialty\r\n        const specialtyKey = Object.keys(audienceInsights.specialty_insights)\r\n          .find(key => key.toLowerCase().includes(specialty.toLowerCase()));\r\n        \r\n        if (specialtyKey && audienceInsights.specialty_insights[specialtyKey].preferences) {\r\n          const preferences = audienceInsights.specialty_insights[specialtyKey].preferences;\r\n          \r\n          if (preferences.topics) {\r\n            preferredTopics = preferences.topics.map(topic => ({\r\n              topic: topic.topic,\r\n              score: topic.count / 10, \r\n              openRate: Math.random() * 30 + 20\r\n            }));\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Find best content for this specialty\r\n      let bestContent = [];\r\n      \r\n      if (topicData?.user_affinities) {\r\n        // Get all topics that users of this specialty engage with\r\n        const specialtyTopics = new Map();\r\n        \r\n        Object.values(topicData.user_affinities).forEach(userAffinities => {\r\n          // Check each topic this user engages with\r\n          Object.entries(userAffinities).forEach(([topic, metrics]) => {\r\n            if (!specialtyTopics.has(topic)) {\r\n              specialtyTopics.set(topic, { score: 0, count: 0 });\r\n            }\r\n            \r\n            specialtyTopics.get(topic).score += metrics.engagement_score || 0;\r\n            specialtyTopics.get(topic).count += 1;\r\n          });\r\n        });\r\n        \r\n        // Get top topics by average engagement score\r\n        bestContent = Array.from(specialtyTopics.entries())\r\n          .map(([topic, data]) => ({\r\n            topic,\r\n            score: data.count > 0 ? data.score / data.count : 0\r\n          }))\r\n          .sort((a, b) => b.score - a.score)\r\n          .slice(0, 5);\r\n      }\r\n      \r\n      // Check statistical validity\r\n      const statisticalValidity = this.calculateStatisticalValidity(userCount);\r\n      \r\n      return {\r\n        specialty,\r\n        userCount,\r\n        engagementMetrics: engagementMetricsData,\r\n        preferredTopics,\r\n        bestContent,\r\n        statisticalValidity\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting specialty engagement:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get specialty comparison based on query entities\r\n   * @param {object} entities - Extracted entities from the query\r\n   * @returns {Promise<object>} Data for specialty comparison\r\n   */\r\n  async getSpecialtyComparison(entities) {\r\n    // Ensure we're initialized\r\n    await this.ensureInitialized();\r\n    \r\n    try {\r\n      // We need at least two specialties to compare\r\n      if (!entities.specialties || entities.specialties.length < 1) {\r\n        throw new Error('At least one specialty required for comparison');\r\n      }\r\n      \r\n      const specialtyList = entities.specialties;\r\n      \r\n      // If only one specialty is specified, add a second common one for comparison\r\n      if (specialtyList.length === 1) {\r\n        specialtyList.push('Dermatology');\r\n      }\r\n      \r\n      // Load necessary data\r\n      const [engagementMetrics, audienceInsights, userProfilesSummary] = await Promise.all([\r\n        this.loadJsonFile('analysis/engagement_metrics.json'),\r\n        this.loadJsonFile('analysis/audience_insights.json'),\r\n        this.loadJsonFile('analysis/user_profiles_summary.json')\r\n      ]);\r\n      \r\n      if (!engagementMetrics && !audienceInsights && !userProfilesSummary) {\r\n        throw new Error('Specialty comparison data not available');\r\n      }\r\n      \r\n      // Prepare comparison data for each specialty\r\n      const specialties = [];\r\n      \r\n      for (const specialty of specialtyList) {\r\n        const specialtyData = {\r\n          specialty,\r\n          userCount: 0,\r\n          engagementMetrics: {\r\n            openRate: 0,\r\n            clickRate: 0,\r\n            responseTime: 0\r\n          },\r\n          topTopics: [],\r\n          devicePreference: 'unknown'\r\n        };\r\n        \r\n        // Get user count\r\n        if (userProfilesSummary?.specialties) {\r\n          // Find closest matching specialty\r\n          const specialtyKey = Object.keys(userProfilesSummary.specialties)\r\n            .find(key => key.toLowerCase().includes(specialty.toLowerCase()));\r\n          \r\n          if (specialtyKey) {\r\n            specialtyData.userCount = userProfilesSummary.specialties[specialtyKey];\r\n          }\r\n        }\r\n        \r\n        // Get engagement metrics\r\n        if (engagementMetrics?.specialty_metrics) {\r\n          // Find closest matching specialty\r\n          const specialtyKey = Object.keys(engagementMetrics.specialty_metrics)\r\n            .find(key => key.toLowerCase().includes(specialty.toLowerCase()));\r\n          \r\n          if (specialtyKey) {\r\n            const metrics = engagementMetrics.specialty_metrics[specialtyKey];\r\n            \r\n            specialtyData.engagementMetrics = {\r\n              openRate: metrics.avg_engagement || 0,\r\n              clickRate: (metrics.avg_engagement / 2) || 0,\r\n              responseTime: metrics.avg_engagement * 3 || 0 \r\n            };\r\n          }\r\n        }\r\n        \r\n        // Get preferred topics\r\n        if (audienceInsights?.specialty_insights) {\r\n          // Find closest matching specialty\r\n          const specialtyKey = Object.keys(audienceInsights.specialty_insights)\r\n            .find(key => key.toLowerCase().includes(specialty.toLowerCase()));\r\n          \r\n          if (specialtyKey && audienceInsights.specialty_insights[specialtyKey].preferences) {\r\n            const preferences = audienceInsights.specialty_insights[specialtyKey].preferences;\r\n            \r\n            if (preferences.topics) {\r\n              specialtyData.topTopics = preferences.topics.map(topic => ({\r\n                topic: topic.topic,\r\n                score: topic.count / 10\r\n              }));\r\n            }\r\n            \r\n            // Get device preference\r\n            if (preferences.devices) {\r\n              const devices = Object.entries(preferences.devices);\r\n              if (devices.length > 0) {\r\n                // Sort by count and get top device\r\n                const [topDevice] = devices.sort((a, b) => b[1] - a[1]);\r\n                if (topDevice) {\r\n                  specialtyData.devicePreference = topDevice[0];\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        \r\n        specialties.push(specialtyData);\r\n      }\r\n      \r\n      return { specialties };\r\n    } catch (error) {\r\n      console.error('Error getting specialty comparison:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get user count based on query entities\r\n   * @param {object} entities - Extracted entities from the query\r\n   * @returns {Promise<object>} Data for user count\r\n   */\r\n  async getUserCount(entities) {\r\n    // Ensure we're initialized\r\n    await this.ensureInitialized();\r\n    \r\n    try {\r\n      // Load user profile summary\r\n      const userProfilesSummary = await this.loadJsonFile('analysis/user_profiles_summary.json');\r\n      \r\n      if (!userProfilesSummary) {\r\n        throw new Error('User profile data not available');\r\n      }\r\n      \r\n      // Get total user count\r\n      const totalUsers = userProfilesSummary.total_profiles || 0;\r\n      \r\n      // If specialty is specified, get count for that specialty\r\n      let specialtyUsers = null;\r\n      let specialty = null;\r\n      \r\n      if (entities.specialties && entities.specialties.length > 0) {\r\n        specialty = entities.specialties[0];\r\n        \r\n        if (userProfilesSummary.specialties) {\r\n          // Find closest matching specialty\r\n          const specialtyKey = Object.keys(userProfilesSummary.specialties)\r\n            .find(key => key.toLowerCase().includes(specialty.toLowerCase()));\r\n          \r\n          if (specialtyKey) {\r\n            specialtyUsers = userProfilesSummary.specialties[specialtyKey];\r\n          }\r\n        }\r\n      }\r\n      \r\n      // If profession is specified, get count for that profession\r\n      let professionUsers = null;\r\n      let profession = null;\r\n      \r\n      if (entities.professions && entities.professions.length > 0) {\r\n        profession = entities.professions[0];\r\n        \r\n        if (userProfilesSummary.profession_breakdown) {\r\n          // Find closest matching profession\r\n          const professionKey = Object.keys(userProfilesSummary.profession_breakdown)\r\n            .find(key => key.toLowerCase().includes(profession.toLowerCase()));\r\n          \r\n          if (professionKey) {\r\n            professionUsers = userProfilesSummary.profession_breakdown[professionKey];\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Determine data confidence\r\n      let confidence = 'high';\r\n      if (totalUsers < 1000) {\r\n        confidence = 'medium';\r\n      }\r\n      if (totalUsers < 100) {\r\n        confidence = 'low';\r\n      }\r\n      \r\n      return {\r\n        totalUsers,\r\n        specialtyUsers,\r\n        specialty,\r\n        professionUsers,\r\n        profession,\r\n        confidence\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting user count:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Get a metric for a specific specialty from engagement metrics\r\n   * @param {object} engagementMetrics - The engagement metrics data\r\n   * @param {string} specialty - The specialty to look up\r\n   * @param {string} metricName - The name of the metric to get\r\n   * @returns {number} The metric value or 0 if not found\r\n   */\r\n  getSpecialtyMetric(engagementMetrics, specialty, metricName) {\r\n    if (!engagementMetrics || !engagementMetrics.specialty_metrics) {\r\n      return 0;\r\n    }\r\n    \r\n    // Find matching specialty\r\n    const specialtyKey = Object.keys(engagementMetrics.specialty_metrics)\r\n      .find(key => key.toLowerCase().includes(specialty.toLowerCase()));\r\n    \r\n    if (!specialtyKey) {\r\n      return 0;\r\n    }\r\n    \r\n    const specialtyMetrics = engagementMetrics.specialty_metrics[specialtyKey];\r\n    \r\n    if (metricName === 'open_rate') {\r\n      return specialtyMetrics.avg_engagement || 0;\r\n    } else if (metricName === 'click_rate') {\r\n      // Sometimes click rate is not directly available, estimate as portion of engagement\r\n      return (specialtyMetrics.avg_engagement / 2) || 0;\r\n    }\r\n    \r\n    return 0;\r\n  }\r\n  \r\n  /**\r\n   * Calculate statistical validity based on sample size\r\n   * @param {number} sampleSize - The sample size\r\n   * @returns {object} Statistical validity metrics\r\n   */\r\n  calculateStatisticalValidity(sampleSize) {\r\n    let confidence_level = 'low';\r\n    if (sampleSize >= 100) {\r\n      confidence_level = 'medium';\r\n    }\r\n    if (sampleSize >= 385) {\r\n      confidence_level = 'high';\r\n    }\r\n    \r\n    const margin_of_error = sampleSize > 0 ? 1 / Math.sqrt(sampleSize) : null;\r\n    \r\n    return {\r\n      sample_size: sampleSize,\r\n      sample_size_adequate: sampleSize >= 30,\r\n      confidence_level,\r\n      margin_of_error\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Ensure the service is initialized\r\n   * @returns {Promise<boolean>} True if initialization is successful\r\n   */\r\n  async ensureInitialized() {\r\n    if (!this.initialized) {\r\n      return await this.initialize();\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * Check if data exists in cache and is not expired\r\n   * @param {string} key - The cache key\r\n   * @returns {any} The cached data or null if not found/expired\r\n   */\r\n  checkCache(key) {\r\n    if (!this.dataCache.has(key)) {\r\n      return null;\r\n    }\r\n    \r\n    const { data, timestamp } = this.dataCache.get(key);\r\n    const now = Date.now();\r\n    \r\n    if (now - timestamp > this.cacheTTL) {\r\n      this.dataCache.delete(key);\r\n      return null;\r\n    }\r\n    \r\n    return data;\r\n  }\r\n  \r\n  /**\r\n   * Set data in the cache\r\n   * @param {string} key - The cache key\r\n   * @param {any} data - The data to cache\r\n   */\r\n  setCache(key, data) {\r\n    this.dataCache.set(key, {\r\n      data,\r\n      timestamp: Date.now()\r\n    });\r\n    \r\n    // Prune cache if it gets too large\r\n    if (this.dataCache.size > 50) {\r\n      const keys = Array.from(this.dataCache.keys());\r\n      const oldestKeys = keys.slice(0, 10);\r\n      oldestKeys.forEach(k => this.dataCache.delete(k));\r\n    }\r\n  }\r\n}\r\n\r\nexport default DataService;"],"names":["constructor","config","arguments","length","undefined","this","accountName","process","containerName","dataCache","Map","cacheTTL","initialized","initialize","testConnection","error","console","testUrl","generateSasUrl","response","fetch","ok","Error","status","blobPath","loadJsonFile","path","cacheKey","cachedData","checkCache","ensureInitialized","url","data","json","setCache","getTopUsers","entities","_entities$specialties","_entities$professions","_entities$topics","_entities$specialties2","_entities$professions2","_entities$topics2","userProfiles","Object","keys","filteredUsers","entries","map","_ref","_profile$personal_inf","_profile$personal_inf2","_profile$personal_inf3","_profile$personal_inf4","_profile$personal_inf5","_profile$engagement_m","_profile$engagement_m2","_profile$engagement_m3","_profile$engagement_m4","_profile$content_pref","email","profile","name","personal_info","first_name","last_name","trim","specialty","profession","profession_type","engagementScore","engagement_metrics","engagement_score","openRate","open_rate","clickRate","click_rate","responseTime","avg_response_time","topics","content_preferences","top_topics","specialties","filter","user","some","s","toLowerCase","includes","professions","p","topic","t","sortMetric","metrics","sort","a","b","limit","users","slice","totalMatching","segment","segmentType","sortedBy","getContentPerformance","_entities$specialties3","_entities$topics3","topicData","topic_summary","contentItems","_ref2","totalSent","total_sent","shareRate","share_rate","item","audienceInsights","specialty_insights","specialtyTopics","flatMap","insights","find","_ref3","preferences","topContent","contentTypes","campaigns","content","getTimingInsights","_timePatterns$overall","_timePatterns$overall2","timePatterns","result","avgTimeToOpen","overall_metrics","average_hours_to_open","medianTimeToOpen","median_hours_to_open","peakHours","hourly_distribution","_ref4","hour","count","parseInt","day_of_week_distribution","dayDistribution","_ref5","day","specialty_metrics","specialtyKey","key","specialtyMetrics","profession_metrics","professionKey","professionMetrics","getAudienceOverview","_engagementMetrics$ov","_engagementMetrics$ov2","_audienceInsights$con","_audienceInsights$con2","_entities$specialties4","userProfilesSummary","engagementMetrics","Promise","all","overallMetrics","totalUsers","total_profiles","avgOpenRate","avg_open_rate","avgClickRate","avg_click_rate","topSpecialties","_ref6","userCount","getSpecialtyMetric","bestTopics","_ref7","bestHours","content_patterns","timing_patterns","best_send_hours","_ref8","segmentSummary","engagement_tiers","highEngagement","highly_engaged","moderateEngagement","moderately_engaged","lowEngagement","low_engagement","_ref9","avgEngagement","avg_engagement","user_count","specialtyInsights","_ref10","dataSources","push","contentPreferences","timing","_dataSources","getUserProfile","matchedEmail","e","personalInfo","journeyPatterns","journey_patterns","getSpecialtyEngagement","engagementMetricsData","preferredTopics","score","Math","random","bestContent","user_affinities","values","forEach","userAffinities","_ref11","has","set","get","Array","from","_ref12","statisticalValidity","calculateStatisticalValidity","getSpecialtyComparison","specialtyList","specialtyData","topTopics","devicePreference","devices","topDevice","getUserCount","specialtyUsers","professionUsers","profession_breakdown","confidence","metricName","sampleSize","confidence_level","sample_size","sample_size_adequate","margin_of_error","sqrt","timestamp","Date","now","delete","size","k"],"sourceRoot":""}